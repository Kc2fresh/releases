'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ui = require('./stores/modules/ui');

var _reactRedux = require('react-redux');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _bind = require('classnames/bind');

var _bind2 = _interopRequireDefault(_bind);

var _helpers = require('./helpers.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PassageSpan = function (_Component) {
  _inherits(PassageSpan, _Component);

  function PassageSpan() {
    _classCallCheck(this, PassageSpan);

    var _this = _possibleConstructorReturn(this, (PassageSpan.__proto__ || Object.getPrototypeOf(PassageSpan)).call(this));

    _this.state = {
      active: null // null, hover, pressed
    };

    _this.handleMouseOver = _this.handleMouseOver.bind(_this);
    _this.handleMouseOut = _this.handleMouseOut.bind(_this);
    _this.handleMouseUp = _this.handleMouseUp.bind(_this);
    return _this;
  }

  _createClass(PassageSpan, [{
    key: 'handleMouseOver',
    value: function handleMouseOver() {
      var _this2 = this;

      this.setState({
        active: "hover"
      }, function () {
        _this2.props.hoverNode(_this2.props.data.id);
      });
    }
  }, {
    key: 'handleMouseOut',
    value: function handleMouseOut() {
      var _this3 = this;

      this.setState({
        active: null
      }, function () {
        _this3.props.hoverNode("none");
      });
    }
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      var _this4 = this;

      this.setState({
        active: "null"
      }, function () {
        var _props = _this4.props,
            data = _props.data,
            expandPathToNode = _props.expandPathToNode,
            focusNode = _props.focusNode;


        expandPathToNode(data.id);
        focusNode(data);
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        active: nextProps.hoverNodeId === this.props.data.id ? "hover" : null
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var active = this.state.active;
      var _props2 = this.props,
          text = _props2.text,
          data = _props2.data,
          styles = _props2.styles,
          selectedNodeId = _props2.selectedNodeId,
          parentId = _props2.parentId,
          depth = _props2.depth,
          hoverNodeId = _props2.hoverNodeId,
          hoverNode = _props2.hoverNode,
          focusNode = _props2.focusNode;

      // Shorthand consts for fragment data

      var segmentsContainer = data.nodeType === "top-level-and";

      function getFragmentData(_ref) {
        var alternateParseInfo = _ref.alternateParseInfo;

        return alternateParseInfo && alternateParseInfo.spanAnnotations ? alternateParseInfo.spanAnnotations : null;
      }

      var fragmentData = getFragmentData(data);
      var textHi = text.length + 1;

      var populateSpans = function populateSpans(children, lo, hi) {
        var fragments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        return children.map(function (childNode) {
          // Shorthand consts for span data
          var hasSpan = childNode.hasOwnProperty("alternateParseInfo") && childNode.alternateParseInfo.hasOwnProperty("charNodeRoot");
          var spanField = hasSpan ? childNode.alternateParseInfo.charNodeRoot : null;
          var spanLo = fragments && hasSpan ? spanField.charLo : 0;
          var spanHi = fragments && hasSpan ? spanField.charHi : textHi;

          // If the child node span fits inside the bounds of the child fragment that triggered this recursion:
          if (spanLo >= lo && spanHi <= hi) {
            return _react2.default.createElement(PassageSpanWrapper, {
              key: childNode.id,
              selectedNodeId: selectedNodeId,
              hoverNodeId: hoverNodeId,
              hoverNode: hoverNode,
              focusNode: focusNode,
              parentId: data.id,
              data: childNode,
              styles: styles,
              text: text,
              depth: depth + 1 });
          }
        });
      };

      var output = null;
      if (fragmentData) {
        output = fragmentData.map(function (item) {
          // If fragment is type child then trigger recursive rendering of children:
          if (item.spanType === "child") {
            return populateSpans(data.children, item.lo, item.hi);
            // Otherwise, render the fragment now:
          } else {
            return _react2.default.createElement(
              'span',
              { key: item.lo + '-' + item.hi, className: 'span-slice__' + item.spanType },
              text.slice(item.lo, item.hi)
            );
          }
        });
      } else {
        // If we don't have fragment data, just display the given text. This means that highlighting
        // won't work.
        output = text;
      }

      // Building list of conditional classes for span-slice
      var spanConditionalClasses = (0, _bind2.default)(_defineProperty({
        "span-slice--hover": active === "hover" || hoverNodeId === data.id,
        "span-slice--pressed": active === "pressed",
        "span-slice--focused": selectedNodeId === data.id,
        "span-slice--margin": depth === 0
      }, 'span-slice--' + (0, _helpers.colorToString)(styles[data.nodeType]), true));

      var onMouseOver = !segmentsContainer ? this.handleMouseOver : null;
      var onMouseOut = !segmentsContainer ? this.handleMouseOut : null;
      var onMouseDown = !segmentsContainer ? function () {
        _this5.setState({ active: "pressed" });
      } : null;
      var onMouseUp = !segmentsContainer ? this.handleMouseUp : null;

      return _react2.default.createElement(
        'span',
        {
          className: 'span-slice ' + spanConditionalClasses,
          'data-parent-id': depth > 0 ? parentId : "null",
          'data-id': data.id,
          onMouseOver: onMouseOver,
          onMouseOut: onMouseOut,
          onMouseDown: onMouseDown,
          onMouseUp: onMouseUp },
        output
      );
    }
  }]);

  return PassageSpan;
}(_react.Component);

PassageSpan.propTypes = {
  text: _react.PropTypes.string.isRequired,
  data: _react.PropTypes.object,
  styles: _react.PropTypes.object,
  parentId: _react.PropTypes.string,
  selectedNodeId: _react.PropTypes.string,
  depth: _react.PropTypes.number,
  hoverNodeId: _react.PropTypes.string,
  hoverNode: _react.PropTypes.func,
  focusNode: _react.PropTypes.func,
  expandPathToNode: _react.PropTypes.func.isRequired

  // We have no state to map to props, so we just return an empty object.
};var mapStateToProps = function mapStateToProps() {
  return {};
};

// When PassageSpan is called recursively, it is using the local definition of the component and not the
// exported, "wrapped with connect" definition, which is a higher-ordered component that has been
// decorated with redux store state. The fix is to assign the wrapped version of Node to a new
// variable here, export that, and call it when we recurse.
var PassageSpanWrapper = (0, _reactRedux.connect)(mapStateToProps, { expandPathToNode: _ui.expandPathToNode })(PassageSpan);

exports.default = PassageSpanWrapper;