'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Link = require('./Link.js');

var _Link2 = _interopRequireDefault(_Link);

var _MiddleParent = require('./MiddleParent.js');

var _MiddleParent2 = _interopRequireDefault(_MiddleParent);

var _ui = require('../stores/modules/ui');

var _bind = require('classnames/bind');

var _bind2 = _interopRequireDefault(_bind);

var _reactRedux = require('react-redux');

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Node = function (_Component) {
  _inherits(Node, _Component);

  function Node() {
    _classCallCheck(this, Node);

    var _this = _possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this));

    _this.state = {
      active: null,
      nodeFocusing: false,
      rollups: true,
      focused: false
    };

    _this.handleNodeMouseUp = _this.handleNodeMouseUp.bind(_this);
    _this.handleUiToggleMouseUp = _this.handleUiToggleMouseUp.bind(_this);
    _this.handlePnToggleMouseUp = _this.handlePnToggleMouseUp.bind(_this);
    _this.handleNodeMouseOver = _this.handleNodeMouseOver.bind(_this);
    _this.handleNodeMouseOut = _this.handleNodeMouseOut.bind(_this);
    _this.handleNodeFocus = _this.handleNodeFocus.bind(_this);
    return _this;
  }

  // Returns arrays of children grouped by positions set in
  // linkToPosition in the JSON:


  _createClass(Node, [{
    key: 'createChildren',
    value: function createChildren(children, positions) {
      return children.reduce(function (children, child) {
        var index = positions[child.link];
        if (index in children) {
          children[index].push(child);
        } else {
          children["down"].push(child);
        }
        return children;
      }, { left: [], right: [], down: [], inside: [] });
    }

    // Returns arrays of inside children grouped by kind:

  }, {
    key: 'countSeqChildren',
    value: function countSeqChildren(children) {
      return children.reduce(function (children, child) {
        var supportedKinds = new Set(["event", "entity", "detail"]);
        if (supportedKinds.has(child.nodeType)) {
          children[child.nodeType].push(child);
        }
        return children;
      }, { event: [], entity: [], detail: [] });
    }

    // Node MouseUp Handler:

  }, {
    key: 'handleNodeMouseUp',
    value: function handleNodeMouseUp(data) {
      var _this2 = this;

      var _props = this.props,
          focusNode = _props.focusNode,
          expandNode = _props.expandNode;


      this.setState({ nodeFocusing: false }, function () {
        focusNode(data);
        expandNode(data.id);
        _this2.handleNodeFocus();
      });
    }

    // UiToggle MouseUp Handler:

  }, {
    key: 'handleUiToggleMouseUp',
    value: function handleUiToggleMouseUp() {
      var _props2 = this.props,
          data = _props2.data,
          toggleNode = _props2.toggleNode;


      toggleNode(data.id);

      this.setState({ active: null });
    }

    // UiParseNav MouseUp Handler:

  }, {
    key: 'handlePnToggleMouseUp',
    value: function handlePnToggleMouseUp(nodeData, direction) {
      var _props3 = this.props,
          data = _props3.data,
          fetchAltParse = _props3.fetchAltParse,
          loading = _props3.loading;


      this.handleNodeMouseUp(data);

      if (!loading) {
        fetchAltParse(nodeData, direction);
      }
    }
  }, {
    key: 'handleNodeMouseOver',
    value: function handleNodeMouseOver() {
      var _this3 = this;

      this.setState({
        active: "hover"
      }, function () {
        _this3.props.hoverNode(_this3.props.data.id);
      });
    }
  }, {
    key: 'handleNodeMouseOut',
    value: function handleNodeMouseOut() {
      var _this4 = this;

      this.setState({
        active: null
      }, function () {
        _this4.props.hoverNode("none");
      });
    }
  }, {
    key: 'handleNodeFocus',
    value: function handleNodeFocus() {
      var _props4 = this.props,
          data = _props4.data,
          expandNode = _props4.expandNode;


      this.setState({
        focused: true,
        nodeFocusing: false
      }, function () {
        expandNode(data.id);
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        active: nextProps.hoverNodeId === this.props.data.id ? "hover" : null
      });

      if (nextProps.selectedNodeId === this.props.data.id) {
        if (nextProps.selectedNodeId !== this.props.selectedNodeId) {
          this.handleNodeFocus();
        }
      } else {
        this.setState({
          focused: false
        });
      }
    }

    // TODO: Try to pull as much business logic out of the render function as possible.

  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var _state = this.state,
          active = _state.active,
          nodeFocusing = _state.nodeFocusing,
          rollups = _state.rollups,
          focused = _state.focused;
      var _props5 = this.props,
          readOnly = _props5.readOnly,
          styles = _props5.styles,
          positions = _props5.positions,
          linkLabels = _props5.linkLabels,
          data = _props5.data,
          layout = _props5.layout,
          depth = _props5.depth,
          parentId = _props5.parentId,
          text = _props5.text,
          selectedNodeId = _props5.selectedNodeId,
          hoverNodeId = _props5.hoverNodeId,
          isSingleSegment = _props5.isSingleSegment,
          focusNode = _props5.focusNode,
          hoverNode = _props5.hoverNode,
          fetchAltParse = _props5.fetchAltParse,
          togglePane = _props5.togglePane,
          directionalChildIndex = _props5.directionalChildIndex,
          loading = _props5.loading,
          expandedNodeIds = _props5.expandedNodeIds;


      var leftChildren = null,
          rightChildren = null,
          downChildren = null,
          insideChildren = null,
          canonicalChildren = null;

      var childNodes = void 0;
      // Immediate child position detection and array building.
      if (data.children) {
        childNodes = this.createChildren(data.children, positions);
      }

      var seqType = null,
          seqChildren = void 0;

      // Setting value of seqType (sequence inherits type based on kind of its inside children)
      if (data.children && data.nodeType === "sequence" && childNodes.inside.length > 0) {
        seqChildren = this.countSeqChildren(childNodes.inside);
        switch (childNodes.inside.length) {
          case seqChildren.event.length:
            seqType = "event";
            break;
          case seqChildren.entity.length:
            seqType = "entity";
            break;
          case seqChildren.detail.length:
            seqType = "detail";
            break;
          default:
            seqType = null;
        }
      }

      var hasChildren = false,
          hasSideChildren = false,
          hasLeftChildren = false,
          hasRightChildren = false,
          hasDownChildren = false,
          hasInsideChildren = false;
      // Testing if there are children.
      if (data.children) {
        // Testing if there are any side children.
        hasChildren = true;
        hasLeftChildren = childNodes.left.length > 0;
        hasRightChildren = childNodes.right.length > 0;
        hasDownChildren = childNodes.down.length > 0;
        hasInsideChildren = childNodes.inside.length > 0;
        hasSideChildren = hasLeftChildren || hasRightChildren ? true : false;
        hasChildren = hasSideChildren || hasDownChildren || hasInsideChildren ? true : false;

        var insertDefocusTrigger = function insertDefocusTrigger(classes) {
          return _react2.default.createElement('div', { className: classes, onDoubleClick: function onDoubleClick() {
              focusNode("defocus");
            } });
        };

        var insertSeqTrigger = function insertSeqTrigger() {
          return _react2.default.createElement('div', { className: 'node-sequence-trigger',
            onClick: function onClick() {
              focusNode(data);
            },
            onMouseOver: _this5.handleNodeMouseOver,
            onMouseOut: _this5.handleNodeMouseOut,
            onMouseDown: function onMouseDown() {
              _this5.setState({ nodeFocusing: true });
            } });
        };

        // Node Children Container template:
        var populateNodes = function populateNodes(nodes, container) {
          return _react2.default.createElement(
            'div',
            { className: 'node-' + (container ? container : "children") + '-container' },
            container !== "sequence" ? insertDefocusTrigger("node-children-container-defocus-trigger") : insertSeqTrigger(),
            nodes.map(function (childNode, index) {
              return _react2.default.createElement(NodeWrapper, {
                key: childNode.id,
                readOnly: readOnly,
                focusNode: focusNode,
                hoverNodeId: hoverNodeId,
                hoverNode: hoverNode,
                fetchAltParse: fetchAltParse,
                togglePane: togglePane,
                selectedNodeId: selectedNodeId,
                styles: styles,
                directionalChildIndex: index,
                isSingleSegment: isSingleSegment,
                loading: loading,
                positions: positions,
                linkLabels: linkLabels,
                parentId: data.id,
                data: childNode,
                layout: layout,
                text: text,
                seqType: seqType,
                depth: depth + 1 });
            })
          );
        };

        // Side and Down Children template:
        var populateDirectionalChildren = function populateDirectionalChildren(direction, children) {
          if (children.length > 0) {
            // Down Children:
            if (direction === "down") {
              return _react2.default.createElement(
                'div',
                { className: 'ft__tr' },
                hasLeftChildren ? insertDefocusTrigger("ft__tr__td ft--left-placeholder") : null,
                _react2.default.createElement(
                  'div',
                  { className: 'ft__tr__td ft--middle-children' },
                  populateNodes(children)
                ),
                hasRightChildren ? insertDefocusTrigger("ft__tr__td ft--right-placeholder") : null
              );
            } else if (direction === "left" || direction === "right") {
              // Side Children:
              return _react2.default.createElement(
                'div',
                { className: 'ft__tr__td ft--' + direction + '-children' },
                insertDefocusTrigger("node-children-container-defocus-trigger"),
                populateNodes(children)
              );
            }
          } else {
            return null;
          }
        };

        // Outputting sets of each type of children.
        if (layout === "canonical" || layout === "default" && !hasSideChildren && !hasInsideChildren) {
          canonicalChildren = populateNodes(data.children);
        } else if (layout === "default" && hasInsideChildren && !hasSideChildren && childNodes.down.length > 0) {
          insideChildren = populateNodes(childNodes.inside, "sequence");
          canonicalChildren = populateNodes(childNodes.down);
        } else if (layout === "default") {
          leftChildren = populateDirectionalChildren("left", childNodes.left);
          rightChildren = populateDirectionalChildren("right", childNodes.right);
          downChildren = populateDirectionalChildren("down", childNodes.down);
          insideChildren = populateNodes(childNodes.inside, "sequence");
        }
      }

      // Determining collapsability and node treatment depending on nesting level.
      var isRoot = !isSingleSegment && depth === 0;
      var isEventRoot = !isSingleSegment && depth === 1 || isSingleSegment && depth === 0;
      var dataCollapsable = hasChildren && depth > 0 && !isEventRoot;

      // Setting value of link position
      var dataPos = "";

      if (data.link) {
        // If a link position is not explicitly set, default to "down".
        if (positions[data.link]) {
          dataPos = positions[data.link];
        } else {
          dataPos = "down";
        }
      }

      if (!isSingleSegment && depth === 1 || isSingleSegment && depth === 0) {
        dataPos = "";
      }

      var isCollapsed = !expandedNodeIds.has(data.id);
      var eventSeqChild = data.nodeType === "event" && dataPos === "inside";
      var encapsulated = (dataPos === "left" || dataPos === "right") && hasSideChildren;
      var notFirstInsideChild = !(data.id !== undefined && dataPos === "inside" && directionalChildIndex === 0);
      var ftCollapsed = isCollapsed && (hasSideChildren || hasDownChildren) && !isRoot && !isEventRoot;

      // ftConditionalClasses builds dynamic class lists for .ft blocks:
      var ftConditionalClasses = (0, _bind2.default)({
        "ft--event": data.nodeType === "event",
        "ft--seq": hasInsideChildren && hasSideChildren,
        "ft--root-event": isEventRoot,
        "ft--encapsulated": encapsulated,
        "ft--event-seq-child": eventSeqChild,
        "ft--no-left-children": hasSideChildren && !hasLeftChildren,
        "ft--no-right-children": hasSideChildren && !hasRightChildren,
        "node-container--collapsed": ftCollapsed,
        "node-container--expanded": !ftCollapsed,
        "node-container--active": active !== null && hasSideChildren,
        "node-container--toggle-ready": active === "toggle-ready"
      });

      var nodeContent = _react2.default.createElement(
        'div',
        { className: 'ft ' + ftConditionalClasses,
          'data-has-children': hasChildren },
        _react2.default.createElement(
          'div',
          { className: 'ft__tr' },
          leftChildren,
          _react2.default.createElement(_MiddleParent2.default, {
            readOnly: readOnly,
            depth: depth,
            directionalChildIndex: directionalChildIndex,
            layout: layout,
            positions: positions,
            linkLabels: linkLabels,
            data: data,
            parentId: parentId,
            hasChildren: hasChildren,
            styles: styles,
            active: active,
            focused: focused,
            collapsed: isCollapsed,
            selectedNodeId: selectedNodeId,
            hoverNodeId: hoverNodeId,
            nodeFocusing: nodeFocusing,
            canonicalChildren: canonicalChildren,
            dataCollapsable: dataCollapsable,
            rollups: rollups,
            isRoot: isRoot,
            encapsulated: encapsulated,
            eventSeqChild: eventSeqChild,
            notFirstInsideChild: notFirstInsideChild,
            isSingleSegment: isSingleSegment,
            text: text,
            dataPos: dataPos,
            togglePane: togglePane,
            isEventRoot: isEventRoot,
            onUiMouseOver: function onUiMouseOver() {
              _this5.setState({ active: "toggle-ready" });
            },
            onPnMouseOver: function onPnMouseOver() {
              _this5.setState({ active: "hover" });
            },
            onUiMouseOut: function onUiMouseOut() {
              _this5.setState({ active: null });
            },
            onPnMouseOut: function onPnMouseOut() {
              _this5.setState({ active: null });
            },
            onMouseDown: function onMouseDown() {
              _this5.setState({ nodeFocusing: true });
            },
            onMouseOver: this.handleNodeMouseOver,
            onMouseOut: this.handleNodeMouseOut,
            onMouseUp: this.handleNodeMouseUp,
            onUiMouseUp: this.handleUiToggleMouseUp,
            onPnMouseUp: this.handlePnToggleMouseUp,
            insideChildren: insideChildren,
            hasInsideChildren: hasInsideChildren,
            hasSideChildren: hasSideChildren,
            hasDownChildren: hasDownChildren,
            seqType: seqType }),
          rightChildren
        ),
        downChildren
      );

      var nodeContentStructure = encapsulated || eventSeqChild ? _react2.default.createElement(
        'div',
        {
          className: 'encapsulated ' + (eventSeqChild ? "event-seq-child" : "") + ' ' + (!isCollapsed && hasChildren ? "event-seq-child--expanded" : ""),
          'data-pos': dataPos },
        eventSeqChild && notFirstInsideChild || encapsulated && dataPos === "right" ? _react2.default.createElement(_Link2.default, { link: data.link, dataPos: dataPos, layout: layout, linkLabels: linkLabels, id: data.id }) : null,
        nodeContent,
        !eventSeqChild && dataPos === "left" ? _react2.default.createElement(_Link2.default, { link: data.link, dataPos: dataPos, layout: layout, linkLabels: linkLabels, id: data.id }) : null
      ) : nodeContent;

      return nodeContentStructure;
    }
  }]);

  return Node;
}(_react.Component);

Node.propTypes = {
  readOnly: _react.PropTypes.bool,
  styles: _react.PropTypes.object.isRequired,
  positions: _react.PropTypes.object.isRequired,
  linkLabels: _react.PropTypes.object.isRequired,
  data: _react.PropTypes.shape({
    attributes: _react.PropTypes.arrayOf(_react.PropTypes.string.isRequired),
    children: _react.PropTypes.arrayOf(_react.PropTypes.object.isRequired),
    link: _react.PropTypes.string,
    id: _react.PropTypes.string
  }),
  depth: _react.PropTypes.number.isRequired,
  layout: _react.PropTypes.string,
  text: _react.PropTypes.string,
  parentId: _react.PropTypes.string,
  selectedNodeId: _react.PropTypes.string,
  hoverNodeId: _react.PropTypes.string,
  isSingleSegment: _react.PropTypes.bool,
  focusNode: _react.PropTypes.func,
  hoverNode: _react.PropTypes.func,
  fetchAltParse: _react.PropTypes.func,
  togglePane: _react.PropTypes.func,
  directionalChildIndex: _react.PropTypes.number,
  loading: _react.PropTypes.bool,
  expandedNodeIds: _react.PropTypes.instanceOf(_immutable2.default.Set).isRequired,
  toggleNode: _react.PropTypes.func.isRequired,
  expandNode: _react.PropTypes.func.isRequired
};

var mapStateToProps = function mapStateToProps(_ref) {
  var ui = _ref.ui;
  return {
    expandedNodeIds: ui.expandedNodeIds
  };
};

// When Node is called recursively, it is using the local definition of the component and not the
// exported, "wrapped with connect" definition, which is a higher-ordered component that has been
// decorated with redux store state. The fix is to assign the wrapped version of Node to a new
// variable here, export that, and call it when we recurse.
var NodeWrapper = (0, _reactRedux.connect)(mapStateToProps, { expandNode: _ui.expandNode, toggleNode: _ui.toggleNode })(Node);

exports.default = NodeWrapper;