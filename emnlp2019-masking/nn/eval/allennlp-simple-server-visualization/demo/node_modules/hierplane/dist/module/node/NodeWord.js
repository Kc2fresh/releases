'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Attributes = require('./Attributes.js');

var _Attributes2 = _interopRequireDefault(_Attributes);

var _Link = require('./Link.js');

var _Link2 = _interopRequireDefault(_Link);

var _UiToggle = require('./UiToggle.js');

var _UiToggle2 = _interopRequireDefault(_UiToggle);

var _UiParseNav = require('./UiParseNav.js');

var _UiParseNav2 = _interopRequireDefault(_UiParseNav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NodeWord = function (_React$Component) {
  _inherits(NodeWord, _React$Component);

  function NodeWord() {
    _classCallCheck(this, NodeWord);

    return _possibleConstructorReturn(this, (NodeWord.__proto__ || Object.getPrototypeOf(NodeWord)).apply(this, arguments));
  }

  _createClass(NodeWord, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          readOnly = _props.readOnly,
          hasInsideChildren = _props.hasInsideChildren,
          layout = _props.layout,
          dataPos = _props.dataPos,
          positions = _props.positions,
          linkLabels = _props.linkLabels,
          data = _props.data,
          text = _props.text,
          onMouseOver = _props.onMouseOver,
          onMouseOut = _props.onMouseOut,
          onMouseDown = _props.onMouseDown,
          _onMouseUp = _props.onMouseUp,
          onUiMouseOver = _props.onUiMouseOver,
          onUiMouseOut = _props.onUiMouseOut,
          onUiMouseUp = _props.onUiMouseUp,
          onPnMouseOver = _props.onPnMouseOver,
          onPnMouseOut = _props.onPnMouseOut,
          onPnMouseUp = _props.onPnMouseUp,
          dataCollapsable = _props.dataCollapsable,
          altParses = _props.altParses,
          rollups = _props.rollups,
          isRoot = _props.isRoot,
          isEventRoot = _props.isEventRoot,
          togglePane = _props.togglePane,
          insideChildren = _props.insideChildren,
          eventSeqChild = _props.eventSeqChild,
          encapsulated = _props.encapsulated,
          notFirstInsideChild = _props.notFirstInsideChild;

      // charNodeRoot is the field in the JSON node object that contains its span's
      // lo and hi values that let the UI extract a phrase from the original query.

      var hasFragments = data.hasOwnProperty("alternateParseInfo") && data.alternateParseInfo.hasOwnProperty("spanAnnotations");
      var hasRollup = rollups && dataCollapsable && hasFragments;
      var fragmentData = hasFragments ? data.alternateParseInfo.spanAnnotations : null;

      // Max rollup characters before node is forced to text wrap
      var maxRollupChars = 40;
      // Boolean that returns true if node span is more than maxRollupChars (used in conditional class of .node__word__label)
      var wideRollup = hasRollup && data.alternateParseInfo.charNodeRoot.charHi - data.alternateParseInfo.charNodeRoot.charLo >= maxRollupChars;

      // Iterates through spanAnnotations to wrap head word ("self") in a <strong> tag
      // so it is visually distinct from the rest of the rollup text.
      var rollupText = hasFragments ? fragmentData.map(function (item, index) {
        if (item.spanType === "self") {
          return _react2.default.createElement(
            'strong',
            { key: index },
            ' ',
            text.slice(item.lo, item.hi),
            ' '
          );
        } else {
          return ' ' + text.slice(item.lo, item.hi) + ' ';
        }
      }) : null;

      var toggle = _react2.default.createElement(_UiToggle2.default, {
        onUiMouseOver: onUiMouseOver,
        onUiMouseOut: onUiMouseOut,
        onUiMouseUp: onUiMouseUp });

      var parseNav = _react2.default.createElement(_UiParseNav2.default, {
        readOnly: readOnly,
        data: data,
        onPnMouseOver: onPnMouseOver,
        onPnMouseOut: onPnMouseOut,
        onPnMouseUp: onPnMouseUp });

      var focusTrigger = _react2.default.createElement('div', { className: 'node-focus-trigger ' + (hasInsideChildren ? "node-focus-trigger--seq" : ""),
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        onMouseDown: onMouseDown,
        onDoubleClick: function onDoubleClick() {
          togglePane("open");
        },
        onMouseUp: function onMouseUp() {
          _onMouseUp(data);
        } });

      return !isRoot ? _react2.default.createElement(
        'div',
        { className: 'node__word\n            ' + (hasInsideChildren && data.attributes.length > 0 ? "node__word--has-attrs" : "") + '\n            ' + (hasRollup ? "node__word--has-rollup" : "") },
        _react2.default.createElement('div', { className: 'node__word__tile' }),
        !isEventRoot && data.link && layout === "canonical" || !isEventRoot && data.link && layout === "default" && positions[data.link] !== "left" && notFirstInsideChild && !encapsulated && !eventSeqChild ? _react2.default.createElement(_Link2.default, { link: data.link, dataPos: dataPos, layout: layout, linkLabels: linkLabels, id: data.id }) : null,
        _react2.default.createElement(
          'div',
          { className: 'node__word__content' },
          _react2.default.createElement(
            'div',
            { className: 'node__word__label ' + (wideRollup ? "node__word__label--wide" : "") },
            _react2.default.createElement(
              'div',
              { className: 'node__word__label__siblings' },
              _react2.default.createElement(
                'span',
                { className: 'node__word__label__headword', id: "node-" + data.id + "-word" },
                data.word
              ),
              hasRollup ? _react2.default.createElement(
                'span',
                { className: 'node__word__label__rollup', id: "node-" + data.id + "-span" },
                rollupText
              ) : null
            )
          ),
          hasInsideChildren ? insideChildren : null,
          _react2.default.createElement(_Attributes2.default, { attrs: data.attributes, id: data.id })
        ),
        !encapsulated && !eventSeqChild && data.link && layout === "default" && positions[data.link] === "left" ? _react2.default.createElement(_Link2.default, { link: data.link, dataPos: dataPos, layout: layout, linkLabels: linkLabels, id: data.id }) : null,
        focusTrigger,
        dataCollapsable ? toggle : null,
        altParses ? parseNav : null
      ) : altParses ? _react2.default.createElement(
        'div',
        { className: 'node__segments' },
        focusTrigger,
        altParses ? parseNav : null
      ) : null;
    }
  }]);

  return NodeWord;
}(_react2.default.Component);

NodeWord.propTypes = {
  readOnly: _react.PropTypes.bool,
  positions: _react.PropTypes.object.isRequired,
  linkLabels: _react.PropTypes.object.isRequired,
  data: _react.PropTypes.shape({
    attributes: _react.PropTypes.arrayOf(_react.PropTypes.string.isRequired)
  }),
  text: _react.PropTypes.string,
  layout: _react.PropTypes.string.isRequired,
  dataPos: _react.PropTypes.string.isRequired,
  hasInsideChildren: _react.PropTypes.bool,
  dataCollapsable: _react.PropTypes.bool.isRequired,
  altParses: _react.PropTypes.bool.isRequired,
  rollups: _react.PropTypes.bool.isRequired,
  isRoot: _react.PropTypes.bool.isRequired,
  isEventRoot: _react.PropTypes.bool.isRequired,
  onMouseOver: _react.PropTypes.func.isRequired,
  onMouseOut: _react.PropTypes.func.isRequired,
  onMouseDown: _react.PropTypes.func.isRequired,
  onMouseUp: _react.PropTypes.func.isRequired,
  onUiMouseOver: _react.PropTypes.func.isRequired,
  onUiMouseOut: _react.PropTypes.func.isRequired,
  onUiMouseUp: _react.PropTypes.func.isRequired,
  onPnMouseOver: _react.PropTypes.func.isRequired,
  onPnMouseOut: _react.PropTypes.func.isRequired,
  onPnMouseUp: _react.PropTypes.func.isRequired,
  togglePane: _react.PropTypes.func,
  insideChildren: _react.PropTypes.object,
  eventSeqChild: _react.PropTypes.bool,
  encapsulated: _react.PropTypes.bool,
  notFirstInsideChild: _react.PropTypes.bool
};

exports.default = NodeWord;