'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MainStage = require('./MainStage.js');

var _MainStage2 = _interopRequireDefault(_MainStage);

var _Passage = require('./Passage.js');

var _Passage2 = _interopRequireDefault(_Passage);

var _SideBar = require('./pane/SideBar.js');

var _SideBar2 = _interopRequireDefault(_SideBar);

var _PaneToggle = require('./pane/PaneToggle.js');

var _PaneToggle2 = _interopRequireDefault(_PaneToggle);

var _ParseTreeToolbar = require('./ParseTreeToolbar.js');

var _ParseTreeToolbar2 = _interopRequireDefault(_ParseTreeToolbar);

var _Toolbar = require('./Toolbar.js');

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _create = require('./stores/create');

var _create2 = _interopRequireDefault(_create);

var _ui = require('./stores/modules/ui');

var _helpers = require('./helpers');

var _IconSprite = require('./IconSprite.js');

var _IconSprite2 = _interopRequireDefault(_IconSprite);

var _reactRedux = require('react-redux');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-multi-comp */

// Local dependencies


// TODO(@codeviking): These dependencies are shared by this component and others. Ideally I'd remove all
// explainer level requirements on these components.


var Tree = function (_Component) {
  _inherits(Tree, _Component);

  _createClass(Tree, null, [{
    key: 'defaultProps',
    get: function get() {
      return {
        router: { transitionTo: function transitionTo() {} },
        urlText: undefined,
        parser: 'default',
        theme: undefined,
        tree: undefined,
        readOnly: true,
        showSidebar: false
      };
    }

    /**
     * @property {object}               [router={}]         a react-router instance
     *                                                      TODO (codeviking): The router shouldn't
     *                                                      be a required property.
     * @property {string}               [urlText=undefined] The sentence text, as entered in the url.
     *                                                      TODO (codeviking): This property shouldn't
     *                                                      exist, there should only be a text property.
     *                                                      We should also remove the "empty" hack.
     * @property {string}               [parser=default]    An identifier for the parser to use when
     *                                                      submitting an API request.
     *                                                      TODO (codeviking): This should not be a
     *                                                      property of the tree.
     * @property {string}               [theme=undefined]   A property for applying a custom theme.
     * @property {object}               [tree=undefined]    The tree to render.
     * @property {readOnly}             [boolean=false]     If true, the UI doesn't allow the end
     *                                                      user to modify the sentence / submit it
     *                                                      to a backend API.
     * @property {showSidebar}          [boolean=true]      If false the sidebar isn't displayed.
     * @property {addAllNodeIds}        {function}          TODO (codeviking): What is this?
     * @property {collapseAllNodes}     {function}          A function which collapses all nodes
     * @property {collapseDescendants}  {function}          A function whichcollapses all descendent nodes
     */

  }, {
    key: 'propTypes',
    get: function get() {
      return {
        router: _react2.default.PropTypes.object.isRequired,
        urlText: _react2.default.PropTypes.string,
        parser: _react2.default.PropTypes.string,
        theme: _react2.default.PropTypes.string,
        tree: _react2.default.PropTypes.object,
        readOnly: _react2.default.PropTypes.bool,
        showSidebar: _react.PropTypes.bool.isRequired,
        addAllNodeIds: _react.PropTypes.func.isRequired,
        collapseAllNodes: _react.PropTypes.func.isRequired,
        collapseDescendants: _react.PropTypes.func.isRequired
      };
    }
  }]);

  function Tree() {
    var _ref;

    _classCallCheck(this, Tree);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = Tree.__proto__ || Object.getPrototypeOf(Tree)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      inputText: null,
      text: "",
      jsonUrl: "",
      styles: {},
      positions: {},
      linkLabels: {},
      data: {},
      jsonData: {},
      // Set layout to 'default' to enable support for side nesting of child nodes.
      // Set layout to 'canonical' to override side nesting and force all nesting down.
      layout: "default",
      selectedNodeId: null,
      hoverNodeId: null,
      selectedData: null,
      sideBarCollapsed: false,
      firstFocus: true,
      loading: null,
      firstLoad: null,
      emptyQuery: null,
      serverEndPoint: null,
      errorState: false
    };
    _this.handleSubmit = _this.handleSubmit.bind(_this);
    _this.handleChange = _this.handleChange.bind(_this);
    _this.focusNode = _this.focusNode.bind(_this);
    _this.hoverNode = _this.hoverNode.bind(_this);
    _this.togglePane = _this.togglePane.bind(_this);
    _this.fetchAltParse = _this.fetchAltParse.bind(_this);

    _this.fetchData = _this.fetchData.bind(_this);
    _this.setCollapsible = _this.setCollapsible.bind(_this);
    _this.populateData = _this.populateData.bind(_this);
    _this.populateError = _this.populateError.bind(_this);
    return _this;
  }

  _createClass(Tree, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.handleEmpty();
    }
  }, {
    key: 'handleEmpty',
    value: function handleEmpty() {
      var urlText = this.props.urlText;


      if (urlText === "empty") {
        this.setState({
          text: "",
          loading: false,
          firstLoad: false,
          emptyQuery: true
        });
      } else {
        this.setState({
          text: decodeURIComponent(urlText),
          loading: true,
          firstLoad: true,
          emptyQuery: false
        });
        this.fetchInitialParse(urlText);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(_ref2) {
      var urlText = _ref2.urlText,
          tree = _ref2.tree;

      var decoded = decodeURI(urlText);

      if (this.state.text !== decoded) {
        this.fetchInitialParse(decoded, tree);
      }
    }
  }, {
    key: 'populateData',
    value: function populateData(data, fetchPath, selectedData) {
      var includesSubTree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      this.setCollapsible(data, selectedData, includesSubTree);
      this.setState({
        inputText: data.text,
        text: data.text,
        styles: data.nodeTypeToStyle || (0, _helpers.generateStylesForNodeTypes)((0, _helpers.findAllNodeTypes)(data.root)),
        positions: data.linkToPosition || {},
        linkLabels: data.linkNameToLabel || {},
        data: data.root,
        jsonData: data,
        loading: false,
        firstLoad: false,
        jsonUrl: fetchPath,
        errorState: false,
        selectedData: selectedData
      });
    }
  }, {
    key: 'populateError',
    value: function populateError(err) {
      console.error(err); // eslint-disable-line no-console
      this.setState({
        inputText: this.state.text,
        styles: {},
        positions: {},
        linkLabels: {},
        data: {},
        loading: false,
        errorState: true,
        selectedData: null
      });
    }

    /**
     * Performs an ajax request and calls a function to handle the returned JSON data.
     *
     * @param {string} fetchPath - api endpoint
     * @param {string} method - HTTP method, e.g., GET, POST
     * @param {object} body - JSON post body
     * @param {boolean} includesSubTree - Whether a subtree is expected in the JSON that is returned.
     *                                    This is true if we're fetching an alternate parse.
     */

  }, {
    key: 'fetchData',
    value: function fetchData(fetchPath, method, body, includesSubTree) {
      var _this2 = this;

      fetch(fetchPath, { method: method, body: body }).then(function (resp) {
        return resp.json();
      }).then(function (data) {
        var _sanitizeResponse = _this2.sanitizeResponse(data, includesSubTree),
            fetchedData = _sanitizeResponse.fetchedData,
            selectedData = _sanitizeResponse.selectedData;

        _this2.populateData(fetchedData, fetchPath, selectedData, includesSubTree);
      }).catch(this.populateError);
    }
  }, {
    key: 'setCollapsible',
    value: function setCollapsible(fetchedData, selectedData) {
      var includesSubTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _props = this.props,
          addAllNodeIds = _props.addAllNodeIds,
          collapseAllNodes = _props.collapseAllNodes,
          collapseDescendants = _props.collapseDescendants;
      // If this is a new query, i.e., not an alternate parse, then clear the expandedNodeIds.
      // Otherwise, collapse all the open descendant nodes.

      if (!includesSubTree) {
        collapseAllNodes();
      } else {
        collapseDescendants(selectedData.id);
      }
      // Add the ids to the UI redux store.
      var root = fetchedData.root;
      addAllNodeIds((0, _helpers.getCollapsibleNodeIds)(root, (0, _helpers.isSingleSegment)(root.nodeType)));
    }

    /**
     * Returns an object with the correct data to generate the UI from.
     *
     * @param {object} data - The response from the api call.
     * @param {boolean} includesSubTree - Whether a subtree is expected in the JSON that is returned.
     *                                    This is true if we're fetching an alternate parse.
     */

  }, {
    key: 'sanitizeResponse',
    value: function sanitizeResponse(data, includesSubTree) {
      return {
        fetchedData: includesSubTree ? data.newCompleteJson : data,
        selectedData: includesSubTree ? data.selectedTree : null
      };
    }

    // Fetch initial parse (takes a query string encoded as a URI):

  }, {
    key: 'fetchInitialParse',
    value: function fetchInitialParse(q, tree) {
      var prefix = "/api/fetchParse.json?text=";
      var fetchPath = prefix + q + "&parser=" + this.props.parser;
      this.setState({
        serverEndPoint: true // HTTP method is get so there is a server endpoint.
      });

      // Check if this is a static explainer instance
      if (!this.props.readOnly) {
        // Calls the method that sends data to the server and returns JSON:
        this.fetchData(fetchPath, "get", {}, false);
      } else {
        // Load static data
        var staticTree = tree || this.props.tree;
        if (staticTree) {
          staticTree.root = (0, _helpers.translateSpans)((0, _helpers.assignNodeIds)(staticTree.root));
        }

        var _sanitizeResponse2 = this.sanitizeResponse(staticTree, false),
            fetchedData = _sanitizeResponse2.fetchedData,
            selectedData = _sanitizeResponse2.selectedData;

        this.populateData(fetchedData, "", selectedData);
      }
    }

    // Fetch alternate parse (takes the data object for the focused node and
    // the direction of the control, prev or next, that called fetchAltParse):

  }, {
    key: 'fetchAltParse',
    value: function fetchAltParse(selectedData, direction) {
      var _this3 = this;

      var altParseInfo = selectedData.alternateParseInfo;
      // This is what gets sent to the server:
      var payload = {
        text: this.state.text,
        nodeId: selectedData.id,
        parseIndex: direction === "next" ? altParseInfo.nextParse : altParseInfo.prevParse,
        rootJsonNode: this.state.data
      };
      this.setState({
        loading: true,
        serverEndPoint: false // HTTP method is post so there is no server endpoint.
      }, function () {
        _this3.fetchData("/api/fetchAlternateParse.json", "post", JSON.stringify(payload), true);
      });
    }
  }, {
    key: 'handleSubmit',
    value: function handleSubmit(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (this.state.inputText !== null) {
          var url = encodeURIComponent(this.state.inputText);
          this.props.router.transitionTo('/explain/' + url);
          // If user submits the same query that has already been parsed then do another fetch
          if (this.state.inputText === this.state.text) {
            this.fetchInitialParse(url);
          }
          this.setState({
            selectedNodeId: null,
            selectedData: null,
            text: e.target.value,
            loading: true
          });
        }
      }
    }
  }, {
    key: 'handleChange',
    value: function handleChange(e) {
      this.setState({
        inputText: e.target.value
      });
    }
  }, {
    key: 'focusNode',
    value: function focusNode(data) {
      if (data !== "defocus") {
        this.setState({
          selectedNodeId: data.id,
          selectedData: data
        });
        if (this.state.firstFocus) {
          this.setState({
            sideBarCollapsed: false,
            firstFocus: false
          });
        }
      } else {
        this.setState({
          selectedNodeId: null,
          selectedData: null
        });
      }
    }
  }, {
    key: 'hoverNode',
    value: function hoverNode(hoverNodeId) {
      this.setState({ hoverNodeId: hoverNodeId });
    }
  }, {
    key: 'togglePane',
    value: function togglePane(mode) {
      switch (mode) {
        case "open":
          this.setState({
            sideBarCollapsed: false
          });
          break;
        case "close":
          this.setState({
            sideBarCollapsed: true
          });
          break;
        default:
          this.setState({
            sideBarCollapsed: !this.state.sideBarCollapsed
          });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          text = _state.text,
          inputText = _state.inputText,
          jsonUrl = _state.jsonUrl,
          styles = _state.styles,
          positions = _state.positions,
          linkLabels = _state.linkLabels,
          data = _state.data,
          jsonData = _state.jsonData,
          layout = _state.layout,
          selectedNodeId = _state.selectedNodeId,
          hoverNodeId = _state.hoverNodeId,
          selectedData = _state.selectedData,
          sideBarCollapsed = _state.sideBarCollapsed,
          loading = _state.loading,
          firstLoad = _state.firstLoad,
          emptyQuery = _state.emptyQuery,
          errorState = _state.errorState,
          serverEndPoint = _state.serverEndPoint;
      var _props2 = this.props,
          readOnly = _props2.readOnly,
          theme = _props2.theme,
          showSidebar = _props2.showSidebar;


      return _react2.default.createElement(
        'div',
        { className: 'hierplane' + (theme !== undefined ? ' hierplane--theme-' + theme : "") },
        _react2.default.createElement(
          'div',
          { className: 'pane-container' },
          _react2.default.createElement(
            'div',
            { className: 'pane pane--scroll' },
            _react2.default.createElement(_Passage2.default, {
              readOnly: readOnly,
              text: text,
              inputText: inputText,
              onKeyPress: this.handleSubmit,
              onChange: this.handleChange,
              focusNode: this.focusNode,
              selectedNodeId: selectedNodeId,
              hoverNodeId: hoverNodeId,
              loading: loading,
              data: data,
              styles: styles,
              hoverNode: this.hoverNode,
              emptyQuery: emptyQuery,
              errorState: errorState }),
            _react2.default.createElement(
              'div',
              { className: 'pane pane--fill' },
              !emptyQuery && !errorState && !loading && !readOnly ? _react2.default.createElement(_Toolbar2.default, {
                jsonUrl: jsonUrl,
                jsonData: jsonData,
                selectedData: selectedData,
                serverEndPoint: serverEndPoint }) : null,
              _react2.default.createElement(_ParseTreeToolbar2.default, {
                disabled: !data || errorState || emptyQuery || loading }),
              _react2.default.createElement(_MainStage2.default, {
                readOnly: readOnly,
                styles: styles,
                positions: positions,
                linkLabels: linkLabels,
                data: data,
                layout: layout,
                text: text,
                focusNode: this.focusNode,
                hoverNode: this.hoverNode,
                fetchAltParse: this.fetchAltParse,
                togglePane: this.togglePane,
                selectedNodeId: selectedNodeId,
                hoverNodeId: hoverNodeId,
                loading: loading,
                firstLoad: firstLoad,
                emptyQuery: emptyQuery,
                errorState: errorState })
            ),
            _react2.default.createElement(_PaneToggle2.default, {
              icon: "sidebar",
              mode: "open",
              sideBarCollapsed: sideBarCollapsed,
              togglePane: this.togglePane })
          ),
          showSidebar ? _react2.default.createElement(_SideBar2.default, {
            readOnly: readOnly,
            text: text,
            selectedData: selectedData,
            loading: loading,
            sideBarCollapsed: sideBarCollapsed,
            fetchAltParse: this.fetchAltParse,
            togglePane: this.togglePane }) : null,
          _react2.default.createElement(_IconSprite2.default, null)
        )
      );
    }
  }]);

  return Tree;
}(_react.Component);

// We have no state to map to props, so we just return an empty object.


var mapStateToProps = function mapStateToProps() {
  return {};
};
var store = (0, _create2.default)();

// This is a hack, as to shim redux in at this level so that all dependencies of the tree are self contained
var ConnectedTree = (0, _reactRedux.connect)(mapStateToProps, { addAllNodeIds: _ui.addAllNodeIds, collapseAllNodes: _ui.collapseAllNodes, collapseDescendants: _ui.collapseDescendants })(Tree);

exports.default = function (_ref3) {
  var props = _objectWithoutProperties(_ref3, []);

  return _react2.default.createElement(
    _reactRedux.Provider,
    { store: store },
    _react2.default.createElement(ConnectedTree, props)
  );
};